# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.async_support.base.exchange import Exchange
import base64
import hashlib
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import OrderNotFound
from ccxt.base.errors import DDoSProtection


class coinsbit(Exchange):

    def describe(self):
        return self.deep_extend(super(coinsbit, self).describe(), {
            'id': 'coinsbit',
            'name': 'Coinsbit',
            'countries': ['EE'],
            'urls': {
                'api': {
                    'public': 'https://coinsbit.io/api/',
                    'private': 'https://coinsbit.io/api/',
                },
                'www': 'https://coinsbit.io/',
                'doc': [
                    'https://www.notion.so/API-COINSBIT-WS-API-COINSBIT-cf1044cff30646d49a0bab0e28f27a87',
                ],
                'fees': 'https://coinsbit.io/fee-schedule',
            },
            'version': 'v1',
            'api': {
                'public': {
                    'get': [
                        'markets',
                        'tickers',
                        'ticker',
                        'book',
                        'history',
                        'history/result',
                        'products',
                        'symbols',
                        'depth/result',
                    ],
                },
                'private': {
                    'post': [
                        'order/new',
                        'order/cancel',
                        'orders',
                        'account/balances',
                        'account/balance',
                        'account/order',
                        'account/order_history',
                    ],
                },
            },
            'has': {
                'cancelOrder': True,
                'CORS': False,
                'createLimitOrder': True,
                'createOrder': True,
                'fetchBalance': True,
                'fetchClosedOrders': True,
                'fetchMarkets': True,
                'fetchMyTrades': True,
                'fetchOHLCV': 'emulated',
                'fetchOpenOrders': True,
                'fetchOrder': False,
                'fetchOrders': False,
                'fetchOrderBook': True,
                'fetchTicker': True,
                'fetchTickers': True,
                'fetchTrades': True,
            },
            'rateLimit': 1000,
            'timeout': 20000, # 10000 is not enough for fetchTickers
            'fees': {
                'trading': {
                    'maker': 0.002,
                    'taker': 0.002,
                },
            },
            'exceptions': {
                'balance not enough': InsufficientFunds,
                'amount is less than': InvalidOrder,
                'Total is less than': InvalidOrder,
                'validation.total': InvalidOrder,
                'Too many requests.': DDoSProtection,
                'This action is unauthorized.': AuthenticationError,
                'order not found': OrderNotFound,
            },
        })

    async def fetch_markets(self, params={}):
        response = await self.publicGetMarkets(params)
        marketsList = self.safe_value(response, 'result')
        parsedMarketList = []
        for marketIndex in range(0, len(marketsList)):
            market = marketsList[marketIndex]
            id = self.safe_string(market, 'name')
            baseId = self.safe_string(market, 'stock')
            quoteId = self.safe_string(market, 'money')
            base = self.safe_currency_code(baseId)
            quote = self.safe_currency_code(quoteId)
            symbol = base + '/' + quote
            isActive = True
            precision = {
                'amount': self.safe_integer(market, 'stockPrec'),
                'price': self.safe_integer(market, 'moneyPrec'),
            }
            limits = {
                'amount': {
                    'min': self.safe_float(market, 'minAmount'),
                    'max': None,
                },
                'price': {
                    'min': None,
                    'max': None,
                },
                'cost': {
                    'min': None,
                    'max': None,
                },
            }
            parsedMarketList.append({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId,
                'quoteId': quoteId,
                'active': isActive,
                'precision': precision,
                'limits': limits,
                'info': market,
            })
        return parsedMarketList

    async def fetch_ticker(self, symbol, params={}):
        await self.load_markets()
        market = self.market(symbol)
        response = await self.publicGetTicker(self.extend({'market': market['id']}, params))
        ticker = self.safe_value(response, 'result')
        return self.parse_ticker(ticker, market)

    async def fetch_tickers(self, symbols=None, params={}):
        await self.load_markets()
        response = await self.publicGetTickers(params)
        tickers = self.safe_value(response, 'result')
        tickersIds = list(tickers.keys())
        parsedTickers = []
        for tickerIndex in range(0, len(tickersIds)):
            tickerId = tickersIds[tickerIndex]
            tickerObject = tickers[tickerId]
            ticker = self.safe_value(tickerObject, 'ticker')
            ticker['at'] = self.safe_value(tickerObject, 'at')
            market = self.safe_value(self.markets_by_id, tickerId)
            parsedTickers.append(self.parse_ticker(ticker, market))
        return self.filter_by_array(parsedTickers, 'symbol', symbols)

    def parse_ticker(self, ticker, market=None):
        symbol = None
        if market is not None:
            symbol = market['symbol']
        timestamp = self.safe_timestamp(ticker, 'at')
        datetime = None
        if timestamp is not None:
            datetime = self.iso8601(timestamp)
        high = self.safe_float(ticker, 'high')
        low = self.safe_float(ticker, 'low')
        bid = self.safe_float(ticker, 'bid')
        ask = self.safe_float(ticker, 'ask')
        open = self.safe_float(ticker, 'open')
        close = self.safe_float(ticker, 'last')
        last = self.safe_float(ticker, 'last')
        change = last - open
        percentage = None
        if open != 0:
            percentage = float(change / open) * float(100)
        average = float(self.sum(last, open)) / float(2)
        baseVolume = None
        if 'vol' in ticker:
            baseVolume = self.safe_float(ticker, 'vol')
        elif 'volume' in ticker:
            baseVolume = self.safe_float(ticker, 'volume')
        quoteVolume = self.safe_float(ticker, 'deal')
        return {
            'symbol': symbol,
            'info': ticker,
            'timestamp': timestamp,
            'datetime': datetime,
            'high': high,
            'low': low,
            'bid': bid,
            'bidVolume': None,
            'ask': ask,
            'askVolume': None,
            'vwap': None,
            'open': open,
            'close': close,
            'last': last,
            'previousClose': None,
            'change': change,
            'percentage': percentage,
            'average': average,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
        }

    async def fetch_order_book(self, symbol, limit=None, params={}):
        await self.load_markets()
        request = {
            'market': self.market_id(symbol),
        }
        if limit is not None:
            request['limit'] = limit
        response = await self.publicGetDepthResult(self.extend(request, params))
        return self.parse_order_book(response, None, 'bids', 'asks')

    async def fetch_trades(self, symbol, since=None, limit=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'market': market['id'],
        }
        if limit is not None:
            request['limit'] = limit
        # 'since' param of the request is required a tid as a value.
        # The exchange will return the trades, starting with self trade id
        if 'tid' in params:
            request['since'] = params['tid']
        else:
            request['since'] = 0
        trades = await self.publicGetHistoryResult(self.extend(request, params))
        return self.parse_trades(trades, market, since, limit, params)

    def parse_trade(self, trade, market=None):
        symbol = None
        currency = None
        if market is not None:
            symbol = market['symbol']
            currency = market['quote']
        id = self.safe_string(trade, 'tid')
        timestamp = None
        if 'date' in trade:
            timestamp = self.safe_timestamp(trade, 'date')
        elif 'time' in trade:
            timestamp = self.safe_timestamp(trade, 'time')
        elif 'ftime' in trade:
            timestamp = self.safe_timestamp(trade, 'ftime')
        datetime = self.iso8601(timestamp)
        side = None
        if 'side' in trade:
            side = self.safe_string(trade, 'side')
        elif 'type' in trade:
            side = self.safe_string(trade, 'type')
        price = self.safe_float(trade, 'price')
        amount = self.safe_float(trade, 'amount')
        cost = None
        if 'total' in trade:
            cost = self.safe_float(trade, 'total')
        elif 'dealMoney' in trade:
            cost = self.safe_float(trade, 'dealMoney')
        if price == 0:
            price = cost / amount
        fee = {
            'currency': currency,
            'cost': self.safe_float(trade, 'dealFee'),
        }
        return {
            'info': trade,
            'id': id,
            'timestamp': timestamp,
            'datetime': datetime,
            'symbol': symbol,
            'order': None,
            'type': None,
            'side': side,
            'takerOrMaker': None,
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': fee,
        }

    async def fetch_balance(self, params={}):
        await self.load_markets()
        response = await self.privatePostAccountBalances(params)
        balances = self.safe_value(response, 'result')
        currencies = list(balances.keys())
        parsedBalances = {}
        for currencyIndex in range(0, len(currencies)):
            currency = currencies[currencyIndex]
            balance = balances[currency]
            parsedBalances[currency] = {
                'free': self.safe_float(balance, 'available'),
                'used': self.safe_float(balance, 'freeze'),
            }
        parsedBalances['info'] = balances
        return self.parse_balance(parsedBalances)

    async def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchOrder requires a symbol argument')
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'market': market['id'],
        }
        if limit is not None:
            symbol['limit'] = limit
        if since is not None:
            symbol['since'] = limit
        response = await self.privatePostOrders(self.extend(request, params))
        orders = self.safe_value(self.safe_value(response, 'result'), 'result')
        return self.parse_orders(orders, market, since, limit, params)

    async def fetch_closed_orders(self, symbol=None, since=None, limit=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchOrder requires a symbol argument')
        await self.load_markets()
        response = await self.privatePostAccountOrderHistory(params)
        result = self.safe_value(response, 'result')
        if isinstance(result, list):
            # User has no closed orders yet.
            return []
        market = self.market(symbol)
        orders = self.safe_value(result, market['id'], [])
        return self.parse_orders(orders, market, since, limit)

    async def fetch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchOrder requires a symbol argument')
        await self.load_markets()
        response = await self.privatePostAccountOrderHistory(params)
        result = self.safe_value(response, 'result')
        if isinstance(result, list):
            # User has no closed orders yet.
            return []
        market = self.market(symbol)
        orders = self.safe_value(result, market['id'], [])
        return self.parse_trades(orders, market, since, limit)

    def parse_order(self, order, market=None):
        id = None
        if 'id' in order:
            id = self.safe_string(order, 'id')
        elif 'orderId' in order:
            id = self.safe_string(order, 'orderId')
        timestamp = None
        if 'timestamp' in order:
            timestamp = self.safe_timestamp(order, 'timestamp')
        elif 'ctime' in order:
            timestamp = self.safe_timestamp(order, 'ctime')
        datetime = self.iso8601(timestamp)
        lastTradeTimestamp = self.safe_timestamp(order, 'ftime')
        marketId = self.safe_string(order, 'market')
        orderMarket = None
        symbol = None
        currency = None
        if marketId in self.markets_by_id:
            orderMarket = self.markets_by_id[marketId]
            symbol = orderMarket['symbol']
            currency = orderMarket['quote']
        type = self.safe_string(order, 'type')
        side = self.safe_string(order, 'side')
        amount = self.safe_float(order, 'amount')
        remaining = self.safe_float(order, 'left')
        status = None
        filled = None
        if remaining is None or remaining == 0.0:
            status = 'closed'
            filled = amount
        else:
            status = 'open'
            filled = amount - remaining
        price = self.safe_float(order, 'price')
        cost = self.safe_float(order, 'dealMoney')
        if price == 0.0:
            if (cost is not None) and (filled is not None):
                if (cost > 0) and (filled > 0):
                    price = cost / filled
        fee = {
            'currency': currency,
            'cost': self.safe_float(order, 'dealFee'),
        }
        return {
            'id': id,
            'datetime': datetime,
            'timestamp': timestamp,
            'lastTradeTimestamp': lastTradeTimestamp,
            'status': status,
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'cost': cost,
            'trades': None,
            'fee': fee,
            'info': order,
        }

    async def create_order(self, symbol, type, side, amount, price=None, params={}):
        if type != 'limit':
            raise ExchangeError(self.id + ' allows limit orders only')
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'market': market['id'],
            'side': side,
            'price': self.price_to_precision(symbol, price),
            'amount': self.amount_to_precision(symbol, amount),
        }
        response = await self.privatePostOrderNew(self.extend(request, params))
        result = self.safe_value(response, 'result')
        return self.parse_order(result, market)

    async def cancel_order(self, id, symbol=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'market': market['id'],
            'orderId': int(id),
        }
        response = await self.privatePostOrderCancel(self.extend(request, params))
        result = self.safe_value(response, 'result')
        return self.parse_order(result, market)

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        url = self.urls['api'][api] + self.version + '/'
        if api == 'public':
            url += 'public/'
        url += self.implode_params(path, params)
        query = self.omit(params, self.extract_params(path))
        if api == 'public':
            queryKeysArray = list(query.keys())
            queryKeysArrayLength = len(queryKeysArray)
            if queryKeysArrayLength > 0:
                url += '?' + self.urlencode(query)
        else:
            self.check_required_credentials()
            request = '/api/' + self.version + '/' + self.implode_params(path, params)
            nonce = str(self.nonce())
            query = self.extend({
                'nonce': nonce,
                'request': request,
            }, query)
            body = self.json(query, {'jsonUnescapedSlashes': True})
            query = self.encode(body)
            payload = base64.b64encode(query)
            secret = self.encode(self.secret)
            signature = self.hmac(payload, secret, hashlib.sha512)
            headers = {
                'Content-type': 'application/json',
                'X-TXC-APIKEY': self.apiKey,
                'X-TXC-PAYLOAD': self.decode(payload),
                'X-TXC-SIGNATURE': signature,
            }
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, code, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if response is None:
            return
        feedback = self.id + ' ' + body
        if code != 200:
            self.throw_exactly_matched_exception(self.httpExceptions, str(code), feedback)
        isSuccess = self.safe_value(response, 'success', True)
        if not isSuccess:
            messages = self.json(self.safe_value(response, 'message'))
            self.throw_broadly_matched_exception(self.exceptions, messages, feedback)
            raise ExchangeError(feedback)
