# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.async_support.base.exchange import Exchange
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import BadRequest
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import DDoSProtection
from ccxt.base.errors import ExchangeNotAvailable
from ccxt.base.decimal_to_precision import TICK_SIZE


class delta(Exchange):

    def describe(self):
        return self.deep_extend(super(delta, self).describe(), {
            'id': 'delta',
            'name': 'Delta Exchange',
            'countries': ['VCT'],
            'version': 'v1',
            'userAgent': 'CCXT',
            'rateLimit': 200,
            'has': {
                'CORS': False,
                'publicAPI': True,
                'privateAPI': True,
                'cancelOrder': True,            # Cancel order
                'createDepositAddress': False,
                'createOrder': True,            # Create order
                'deposit': False,
                'fetchBalance': True,           # Fetch wallet balance
                'fetchClosedOrders': True,      # Fetch closed/cancelled orders
                'fetchCurrencies': False,
                'fetchDepositAddress': False,
                'fetchMarkets': True,           # Fetch all live contracts
                'fetchMyTrades': True,          # Fetch my fills
                'fetchOHLCV': True,             # Fetch OHLCV for a symbol
                'fetchOpenOrders': True,        # Fetch my open orders
                'fetchOrder': False,
                'fetchOrderBook': True,         # Fetch l2 orderbook
                'fetchOrders': True,            # Fetch all orders
                'fetchTicker': True,            # Fetch 24 hr ticket for a symbol
                'fetchTickers': False,
                'fetchBidsAsks': False,
                'fetchTrades': True,            # Fetch recent trades of a contract
                'withdraw': False,
            },
            'timeframes': {
                '1m': '1',
                '3m': '3',
                '5m': '5',
                '15m': '15',
                '30m': '30',
                '1h': '60',
                '2h': '120',
                '4h': '240',
                '6h': '360',
                '1d': 'D',
                '7d': '7D',
                '30d': '30D',
                '1w': '1W',
                '2w': '2W',
            },
            'urls': {
                'test': 'https://testnet-api.delta.exchange',
                'logo': 'https://docs.delta.exchange/images/delta-logo-with-text.png',
                'api': 'https://api.delta.exchange',
                'www': 'https://www.delta.exchange/app',
                'doc': 'https://docs.delta.exchange/',
                'fees': 'https://www.delta.exchange/fees/',
                'referral': 'https://www.delta.exchange/referral-program/',
            },
            'api': {
                'public': {
                    'get': ['products', 'orderbook/{id}/l2', 'products/ticker/24hr', 'chart/history'],
                },
                'private': {
                    'get': ['positions', 'orders', 'orders/leverage', 'orders/history', 'fills', 'wallet/balances', 'wallet/transactions'],
                    'post': ['orders', 'orders/leverage', 'positions/change_margin'],
                    'delete': ['orders'],
                    'put': ['orders'],
                },
            },
            'exceptions': {
                'exact': {
                    'ServerOverload': ExchangeNotAvailable,
                    'Timeout': ExchangeNotAvailable,
                    'UnauthorizedApiAccess': AuthenticationError,
                    'InvalidOrder': InvalidOrder,
                    'InsufficientMargin': InsufficientFunds,
                },
            },
            'precisionMode': TICK_SIZE,
        })

    async def fetch_markets(self, params={}):
        response = await self.publicGetProducts()
        result = []
        for i in range(0, len(response)):
            market = response[i]
            id = market['id']
            baseId = market['underlying_asset']['symbol']
            quoteId = market['quoting_asset']['symbol']
            base = self.safe_currency_code(baseId)
            quote = self.safe_currency_code(quoteId)
            symbolId = market['symbol']
            symbol = symbolId
            if (baseId + quoteId) == symbolId:
                symbol = base + '/' + quote
            tickSize = self.safe_float(market, 'tick_size')
            active = (market['trading_status'] == 'operational')
            taker = self.safe_float(market, 'commission_rate')
            maker = self.safe_float(market, 'maker_commission_rate')
            limits = {
                'amount': {
                    'min': 1,
                    'max': None,
                },
                'price': {
                    'min': tickSize,
                    'max': None,
                },
                'cost': {
                    'min': None,
                    'max': None,
                },
            }
            precision = {
                'amount': 1,
                'price': tickSize,
            }
            result.append({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId,
                'quoteId': quoteId,
                'maker': maker,
                'taker': taker,
                'limits': limits,
                'precision': precision,
                'type': 'future',
                'spot': False,
                'future': True,
                'swap': False,
                'active': active,
                'info': market,
            })
        return result

    async def fetch_order_book(self, symbol, params={}):
        await self.load_markets()
        id = self.market_id(symbol)
        response = await self.publicGetOrderbookIdL2(self.extend({'id': id}, params))
        orderbook = self.parse_order_book(response, None, 'buy_book', 'sell_book', 'price', 'size')
        return orderbook

    async def fetch_ticker(self, symbol, params={}):
        ticker = await self.publicGetProductsTicker24hr(self.extend(
            {
                'symbol': symbol,
            },
            params
        ))
        return self.parse_ticker(ticker)

    async def fetch_trades(self, symbol, since=None, limit=50, params={}):
        await self.load_markets()
        market = self.market(symbol)
        response = await self.publicGetOrderbookIdL2(self.extend({'id': market['id']}, params))
        return self.parse_trades(response['recent_trades'], market, since, limit)

    async def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        currentTime = self.seconds()
        periodDurationInSeconds = self.parse_timeframe(timeframe)
        # max limit is 2000, but the exact timestamp can't be pinpointed due to
        # empty volume candles being skipped
        request = self.extend({
            'symbol': market['info']['symbol'],
            'resolution': self.timeframes[timeframe],
            'from': 1514764800,  # 2018-01-01T00:00:00.000Z
            'to': currentTime,
        }, params)
        if since is not None:
            request['from'] = self.truncate(since / 1000)
            #if limit is not None:
            #    request['to'] = request['from'] + (limit *  periodDurationInSeconds)
            #}
        # elif limit is not None:
        #    request['from'] = currentTime - limit * periodDurationInSeconds
        #}
        response = await self.publicGetChartHistory(request)
        if response['s'] == 'ok':
            return self.parse_trading_view_ohlcv(response, None, timeframe, since, limit)
        else:
            return []

    async def fetch_balance(self, params={}):
        wallets = await self.privateGetWalletBalances()
        response = {}
        for i in range(0, len(wallets)):
            wallet = wallets[i]
            total = float(wallet['balance'])
            used = float(wallet['order_margin']) + float(wallet['position_margin']) + float(wallet['commission'])
            response[wallet['asset']['symbol']] = {
                'free': total - used,
                'used': used,
                'total': total,
            }
        return self.parse_balance(response)

    async def get_orders(self, symbol, params={}):
        await self.load_markets()
        request = {}
        market = self.market(symbol)
        request.product_id = market['id']
        response = await self.privateGetOrders(self.extend(request, params))
        return self.parse_orders(response, market)

    async def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        response = await self.get_orders(
            symbol,
            self.extend(
                {
                    'state': 'open',
                },
                params
            )
        )
        return response

    async def fetch_closed_orders(self, symbol=None, since=None, limit=None, params={}):
        response = await self.get_orders(
            symbol,
            self.extend(
                {
                    'state': 'closed',
                },
                params
            )
        )
        return response

    async def create_order(self, symbol, type, side, amount, price=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'product_id': market['id'],
            'order_type': self.get_order_type(type),
            'side': side,
            'size': amount,
        }
        if price is not None:
            request['limit_price'] = price
        response = await self.privatePostOrders(self.extend(request, params))
        order = self.parse_order(response, market)
        return order

    async def cancel_order(self, id, symbol=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        response = await self.privateDeleteOrders(self.extend(
            {
                'id': id,
                'product_id': market['id'],
            },
            params
        ))
        order = self.parse_order(response, market)
        return order

    async def fetch_positions(self):
        response = await self.privateGetPositions()
        return response

    async def fetch_order_leverage(self, symbol):
        await self.load_markets()
        response = await self.privateGetOrdersLeverage({
            'product_id': self.market_id(symbol),
        })
        return response

    async def change_position_margin(self, symbol, deltaMargin):
        await self.load_markets()
        response = await self.privatePostPositionsChangeMargin({
            'product_id': self.market_id(symbol),
            'delta_margin': deltaMargin,
        })
        return response

    async def change_order_leverage(self, symbol, leverage):
        await self.load_markets()
        response = await self.privatePostOrdersLeverage({
            'product_id': self.market_id(symbol),
            'leverage': leverage,
        })
        return response

    def handle_errors(self, code, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if code == 429:
            raise DDoSProtection(self.id + ' ' + body)
        if code >= 400:
            error = ''
            if response['error']:
                error = self.safe_string(response, 'error')
            elif response['errors']:
                errors = []
                for i in range(0, len(response['errors'])):
                    errors.append(self.safe_string(response['errors'][i], 'msg'))
                error = ', '.join(errors)
            feedback = self.id + ' ' + error
            exact = self.exceptions['exact']
            if error in exact:
                raise exact[error](feedback)
            if code == 400:
                raise BadRequest(feedback)
            raise ExchangeError(feedback)

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        url = self.urls['api'] + '/' + self.implode_params(path, params)
        query = self.omit(params, self.extract_params(path))
        if method == 'GET':
            if query:
                url += '?' + self.urlencode(query)
        if api == 'private':
            self.check_required_credentials()
            if method != 'GET':
                if query:
                    body = self.json(query)
            timestamp = self.seconds()
            signatureData = method + timestamp
            if path[0] == '/':
                signatureData += path
            else:
                signatureData += '/' + path
            if method == 'GET':
                if query:
                    signatureData += '?' + self.urlencode(query)
            if body is not None:
                signatureData += body
            signature = self.hmac(
                self.encode(signatureData),
                self.encode(self.secret)
            )
            headers = {
                'Content-Type': 'application/json',
                'api-key': self.apiKey,
                'timestamp': timestamp,
                'signature': signature,
            }
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def parse_ticker(self, ticker):
        timestamp = self.safe_integer(ticker, 'timestamp') * 1000
        iso8601 = self.iso8601(timestamp)
        symbol = self.safe_string(ticker, 'symbol')
        last = self.safe_float(ticker, 'close')
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': iso8601,
            'high': self.safe_float(ticker, 'high'),
            'low': self.safe_float(ticker, 'low'),
            'bid': last,    # for now we are considering bid as last, we will fix self in delta v2(our next version)
            'bidVolume': None,
            'ask': last,    # for now we are considering ask as last, we will fix self in delta v2(our next version)
            'askVolume': None,
            'vwap': None,
            'open': self.safe_float(ticker, 'open'),
            'close': last,
            'last': last,
            'previousClose': None,
            'change': None,
            'percentage': None,
            'average': None,
            'baseVolume': None,
            'quoteVolume': self.safe_float(ticker, 'volume'),
            'info': ticker,
        }

    def parse_trade(self, trade, market):
        timestamp = int(self.safe_integer(trade, 'timestamp') / 1000)
        iso8601 = self.iso8601(timestamp)
        symbol = market['symbol']
        side = trade['buyer_role'] == 'buy' if 'taker' else 'sell'
        size = self.safe_integer(trade, 'size')
        price = self.safe_float(trade, 'price')
        cost = self.get_notional(size, price, market)
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': iso8601,
            'symbol': symbol,
            'id': None,
            'order': None,
            'type': None,
            'side': side,
            'price': price,
            'amount': size,
            'takerOrMaker': 'taker',
            'cost': cost,
            'fee': None,
        }

    def parse_order_status(self, status):
        statuses = {
            'open': 'open',
            'cancelled': 'canceled',
            'closed': 'closed',
        }
        if status in statuses:
            return statuses[status]
        return status

    def get_order_type(self, order_type):
        order_types = {
            'limit': 'limit_order',
            'market': 'market_order',
        }
        if order_type in order_types:
            return order_types[order_type]
        return order_type

    def parse_order_type(self, order_type):
        order_types = {
            'limit_order': 'limit',
            'market_order': 'market',
        }
        if order_type in order_types:
            return order_types[order_type]
        return order_type

    def parse_order(self, order, market):
        created_at = self.safe_string(order, 'created_at')
        timestamp = self.parse8601(created_at)
        id = self.safe_string(order, 'id')
        price = self.safe_float(order, 'limit_price')
        average = self.safe_float(order, 'avg_fill_price')
        amount = self.safe_integer(order, 'size')
        filled = self.safe_integer(order, 'size') - self.safe_integer(order, 'unfilled_size')
        remaining = amount - filled
        status = self.parse_order_status(self.safe_string(order, 'state'))
        side = self.safe_string(order, 'side')
        type = self.parse_order_type(self.safe_string(order, 'order_type'))
        return {
            'info': order,
            'id': id,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'symbol': market['symbol'],
            'type': type,
            'side': side,
            'price': price,
            'amount': amount,
            'cost': None,
            'average': average,
            'filled': filled,
            'remaining': remaining,
            'status': status,
            'fee': None,
            'trades': None,  # todo: parse trades
        }

    def get_notional(self, size, price, market):
        contract_value = self.safe_float(market['info'], 'contract_value')
        if market['info']['product_type'] == 'inverse_future':
            return size * contract_value / price
        else:
            return size * contract_value * price
