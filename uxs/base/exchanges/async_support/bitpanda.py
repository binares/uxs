# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.async_support.base.exchange import Exchange
import math
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import PermissionDenied
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadRequest
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import OrderNotFound
from ccxt.base.errors import DDoSProtection
from ccxt.base.errors import ExchangeNotAvailable


class bitpanda(Exchange):

    def describe(self):
        return self.deep_extend(super(bitpanda, self).describe(), {
            'id': 'bitpanda',
            'name': 'Bitpanda Global Exchange',
            'countries': ['AT'],
            'rateLimit': 500,
            'has': {
                'cancelAllOrders': True,
                'cancelOrder': True,
                'CORS': True,
                'createDepositAddress': True,
                'createLimitOrder': True,
                'createMarketOrder': True,
                'createOrder': True,
                'deposit': True,
                'fetchBalance': True,
                'fetchClosedOrders': True,
                'fetchCurrencies': True,
                'fetchDepositAddress': True,
                'fetchL2OrderBook': True,
                'fetchMarkets': True,
                'fetchMyTrades': True,
                'fetchOHLCV': True,
                'fetchOpenOrders': True,
                'fetchOrder': True,
                'fetchOrderBook': True,
                'fetchOrders': True,
                'fetchStatus': 'emulated',
                'fetchTicker': True,
                'fetchTickers': True,
                'fetchTime': True,
                'fetchTrades': False,
                'fetchTradingFees': True,
                'privateAPI': True,
                'publicAPI': True,
                'withdraw': True,
            },
            'timeframes': {
                '1m': {
                    'period': 1,
                    'unit': 'MINUTES',
                },
                '5m': {
                    'period': 5,
                    'unit': 'MINUTES',
                },
                '15m': {
                    'period': 15,
                    'unit': 'MINUTES',
                },
                '30m': {
                    'period': 30,
                    'unit': 'MINUTES',
                },
                '1h': {
                    'period': 1,
                    'unit': 'HOURS',
                },
                '4h': {
                    'period': 4,
                    'unit': 'HOURS',
                },
                '1d': {
                    'period': 1,
                    'unit': 'DAYS',
                },
                '1w': {
                    'period': 1,
                    'unit': 'WEEKS',
                },
                '1M': {
                    'period': 1,
                    'unit': 'MONTHS',
                },
            },
            'version': 'v1',
            'urls': {
                'api': {
                    'v1': 'https://api.exchange.bitpanda.com/public/',
                    'public': 'https://api.exchange.bitpanda.com/public/',
                    'private': 'https://api.exchange.bitpanda.com/public/',
                },
                'www': 'https://www.bitpanda.com',
                'doc': [
                    'https://developers.bitpanda.com/exchange/',
                ],
                'fees': 'https://www.bitpanda.com/en/exchange/fees',
            },
            'api': {
                'public': {
                    'get': [
                        'candlesticks/{instrument}',
                        'currencies',
                        'instruments',
                        'market-ticker',
                        'market-ticker/{instrument}',
                        'order-book/{instrument}',
                        'time',
                    ],
                },
                'private': {
                    'get': [
                        'account/balances',
                        'account/deposit/crypto/{id}',
                        'account/fees',
                        'account/orders',
                        'account/orders/{id}',
                        'account/trades',
                        'account/trading-volume',
                    ],
                    'post': [
                        'account/deposit/crypto',
                        'account/orders',
                        'account/withdraw/crypto',
                    ],
                    'delete': [
                        'account/orders',
                        'account/orders/{id}',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'tierBased': True,
                    'percentage': True,
                    'taker': 0.1 / 100,
                    'maker': 0.1 / 100,
                },
            },
            'requiredCredentials': {
                'apiKey': True,
                'secret': False,
            },
            'options': {
                'with_just_filled_inactive': False,
                'with_cancelled_and_rejected': False,
            },
            'exceptions': {
                'INVALID_CREDENTIALS': AuthenticationError,
                'MISSING_CREDENTIALS': AuthenticationError,
                'INVALID_APIKEY': AuthenticationError,
                'INVALID_SCOPES': AuthenticationError,
                'INVALID_SUBJECT': AuthenticationError,
                'INVALID_ISSUER': AuthenticationError,
                'INVALID_AUDIENCE': AuthenticationError,
                'INVALID_DEVICE_ID': AuthenticationError,
                'INVALID_IP_RESTRICTION': AuthenticationError,
                'APIKEY_REVOKED': AuthenticationError,
                'APIKEY_EXPIRED': AuthenticationError,
                'SYNCHRONIZER_TOKEN_MISMATCH': AuthenticationError,
                'SESSION_EXPIRED': AuthenticationError,
                'INTERNAL_ERROR': AuthenticationError,
                'CLIENT_IP_BLOCKED': PermissionDenied,
                'MISSING_PERMISSION': PermissionDenied,
                'ILLEGAL_CHARS': BadRequest,
                'UNSUPPORTED_MEDIA_TYPE': BadRequest,
                'ACCOUNT_HISTORY_TIME_RANGE_TOO_BIG': BadRequest,
                'CANDLESTICKS_TIME_RANGE_TOO_BIG': BadRequest,
                'INVALID_INSTRUMENT_CODE': BadRequest,
                'INVALID_ORDER_TYPE': BadRequest,
                'INVALID_UNIT': BadRequest,
                'INVALID_PERIOD': BadRequest,
                'INVALID_TIME': BadRequest,
                'INVALID_DATE': BadRequest,
                'INVALID_CURRENCY': BadRequest,
                'INVALID_AMOUNT': BadRequest,
                'INVALID_PRICE': BadRequest,
                'INVALID_LIMIT': BadRequest,
                'INVALID_QUERY': BadRequest,
                'INVALID_CURSOR': BadRequest,
                'INVALID_ACCOUNT_ID': BadRequest,
                'INVALID_SIDE': BadRequest,
                'INVALID_ACCOUNT_HISTORY_FROM_TIME': BadRequest,
                'INVALID_ACCOUNT_HISTORY_MAX_PAGE_SIZE': BadRequest,
                'INVALID_ACCOUNT_HISTORY_TIME_PERIOD': BadRequest,
                'INVALID_ACCOUNT_HISTORY_TO_TIME': BadRequest,
                'INVALID_CANDLESTICKS_GRANULARITY': BadRequest,
                'INVALID_CANDLESTICKS_UNIT': BadRequest,
                'INVALID_ORDER_BOOK_DEPTH': BadRequest,
                'INVALID_ORDER_BOOK_LEVEL': BadRequest,
                'INVALID_PAGE_CURSOR': BadRequest,
                'INVALID_TIME_RANGE': BadRequest,
                'INVALID_TRADE_ID': BadRequest,
                'INVALID_UI_ACCOUNT_SETTINGS': BadRequest,
                'NEGATIVE_AMOUNT': BadRequest,
                'NEGATIVE_PRICE': BadRequest,
                'MIN_SIZE_NOT_SATISFIED': BadRequest,
                'BAD_AMOUNT_PRECISION': BadRequest,
                'BAD_PRICE_PRECISION': BadRequest,
                'BAD_TRIGGER_PRICE_PRECISION': BadRequest,
                'MAX_OPEN_ORDERS_EXCEEDED': BadRequest,
                'MISSING_PRICE': ArgumentsRequired,
                'MISSING_ORDER_TYPE': ArgumentsRequired,
                'MISSING_SIDE': ArgumentsRequired,
                'MISSING_CANDLESTICKS_PERIOD_PARAM': ArgumentsRequired,
                'MISSING_CANDLESTICKS_UNIT_PARAM': ArgumentsRequired,
                'MISSING_FROM_PARAM': ArgumentsRequired,
                'MISSING_INSTRUMENT_CODE': ArgumentsRequired,
                'MISSING_ORDER_ID': ArgumentsRequired,
                'MISSING_TO_PARAM': ArgumentsRequired,
                'MISSING_TRADE_ID': ArgumentsRequired,
                'INVALID_ORDER_ID': OrderNotFound,
                'NOT_FOUND': OrderNotFound,
                'INSUFFICIENT_LIQUIDITY': InsufficientFunds,
                'INSUFFICIENT_FUNDS': InsufficientFunds,
                'NO_TRADING': ExchangeNotAvailable,
                'SERVICE_UNAVAILABLE': ExchangeNotAvailable,
                'GATEWAY_TIMEOUT': ExchangeNotAvailable,
                'RATELIMIT': DDoSProtection,
                'CF_RATELIMIT': DDoSProtection,
                'INTERNAL_SERVER_ERROR': ExchangeError,
            },
        })

    async def cancel_all_orders(self, symbol=None, params={}):
        await self.load_markets()
        request = {}
        if symbol is not None:
            request['instrument_code'] = self.market_id(symbol)
        return await self.privateDeleteAccountOrders(self.extend(request, params))

    async def cancel_order(self, id, symbol=None, params={}):
        await self.load_markets()
        request = {
            'id': id,
        }
        return await self.privateDeleteAccountOrdersId(self.extend(request, params))

    async def create_deposit_address(self, code, params={}):
        await self.load_markets()
        currency = self.currency(code)
        request = {
            'currency': currency['id'],
        }
        response = await self.privatePostAccountDepositCrypto(self.extend(request, params))
        address = self.safe_string(response, 'address')
        tag = self.safe_string(response, 'destination_tag')
        self.check_address(address)
        return {
            'currency': code,
            'address': address,
            'tag': tag,
            'info': response,
        }

    async def create_order(self, symbol, type, side, amount, price=None, params={}):
        await self.load_markets()
        request = {
            'instrument_code': self.market_id(symbol),
            'side': side.upper(),
            'type': type.upper(),
            'amount': self.amount_to_precision(symbol, amount),
        }
        if type == 'limit' or self.safe_string(params, 'type') == 'stoplimit':
            request['price'] = self.price_to_precision(symbol, price)
        if self.safe_string(params, 'type') == 'stoplimit':
            request['trigger_price'] = self.price_to_precision(symbol, self.safe_float(params, 'stopPrice'))
        response = await self.privatePostAccountOrders(self.extend(request, params))
        return self.parse_order(response)

    async def fetch_balance(self, params={}):
        await self.load_markets()
        response = await self.privateGetAccountBalances(params)
        balances = self.safe_value(response, 'balances')
        result = {
            'info': response,
        }
        for i in range(0, len(balances)):
            balance = balances[i]
            currencyCode = self.safe_string(balance, 'currency_code')
            code = self.safe_currency_code(currencyCode)
            account = self.account()
            account['free'] = self.safe_float(balance, 'available')
            account['used'] = self.safe_float(balance, 'locked')
            result[code] = account
        return self.parse_balance(result)

    async def fetch_closed_orders(self, symbol=None, since=None, limit=None, params={}):
        params['with_cancelled_and_rejected'] = False
        params['with_just_filled_inactive'] = True
        return await self.fetch_orders(symbol, since, limit, params)

    async def fetch_currencies(self, params={}):
        response = await self.publicGetCurrencies(params)
        result = {}
        for i in range(0, len(response)):
            currency = response[i]
            id = self.safe_string(currency, 'code')
            code = self.safe_currency_code(id)
            precision = self.safe_integer(currency, 'precision')
            result[code] = {
                'id': id,
                'code': code,
                'info': currency,
                'name': code,
                'active': None,
                'fee': None,
                'precision': precision,
                'limits': None,
            }
        return result

    async def fetch_deposit_address(self, code, params={}):
        await self.load_markets()
        currency = self.currency(code)
        request = {
            'id': currency['id'],
        }
        response = await self.privateGetAccountDepositCryptoId(self.extend(request, params))
        address = self.safe_string(response, 'address')
        tag = self.safe_string(response, 'destination_tag')
        self.check_address(address)
        return {
            'currency': code,
            'address': address,
            'tag': tag,
            'info': response,
        }

    async def fetch_l2_order_book(self, symbol, limit=None, params={}):
        await self.load_markets()
        request = {
            'instrument': self.market_id(symbol),
            'level': 2,
        }
        return await self.parse_book(request, params)

    async def fetch_markets(self, params={}):
        response = await self.publicGetInstruments()
        result = []
        for i in range(0, len(response)):
            market = response[i]
            baseId = self.safe_string(market['base'], 'code')
            quoteId = self.safe_string(market['quote'], 'code')
            base = self.safe_currency_code(baseId)
            quote = self.safe_currency_code(quoteId)
            id = base + '_' + quote
            symbol = base + '/' + quote
            active = self.safe_string(market, 'state') == 'ACTIVE'
            precision = {
                'price': self.safe_integer(market, 'market_precision'),
                'amount': self.safe_integer(market, 'amount_precision'),
            }
            limits = {
                'amount': {
                    'min': self.safe_float(market, 'min_size'),
                    'max': None,
                },
                'price': {
                    'min': math.pow(10, -precision['price']),
                    'max': None,
                },
            }
            limits['cost'] = {
                'min': limits['amount']['min'] * limits['price']['min'],
                'max': None,
            }
            result.append({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId,
                'quoteId': quoteId,
                'active': active,
                'precision': precision,
                'limits': limits,
                'info': market,
            })
        return result

    async def fetch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        await self.load_markets()
        request = {}
        market = None
        if symbol is not None:
            market = self.market(symbol)
            request['instrument_code'] = market['id']
        # from and to parameters are mutually inclusive
        if since is not None:
            # we define now as default to parameter
            to = self.iso8601(self.milliseconds())
            if 'to' in params:
                to = self.safe_string(params, 'to')
            request['to'] = to
            request['from'] = self.iso8601(since)
        if limit is not None:
            request['max_page_size'] = limit
        response = await self.privateGetAccountTrades(self.extend(request, params))
        trades = self.safe_value(response, 'trade_history')
        if 'cursor' in response:
            cursor = self.safe_value(response, 'cursor')
            return self.add_paginator_cursor(self.parse_trades(trades, market, since, limit, params), cursor)
        return self.parse_trades(trades, market, since, limit, params)

    async def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
        # maximum supported by bitpanda pro
        MAX_LIMIT = 1000
        await self.load_markets()
        granularity = self.timeframes[timeframe]
        # sanity checks
        if granularity is None:
            raise ExchangeError(self.id + ' does not have the timeframe option: ' + timeframe)
        if since is None:
            raise ExchangeError(self.id + ' since needs to defined for OHLC')
        if limit is None or limit > MAX_LIMIT:
            limit = MAX_LIMIT
        market = self.market(symbol)
        duration = self.parse_timeframe(timeframe)
        # max time period in ms wrt granularity and limit
        maxTimePeriod = (limit - 1) * duration * 1000
        if 'to' in params:
            if params['to'] <= self.sum(maxTimePeriod, since):
                params['to'] = self.iso8601(params['to'])
            else:
                raise ExchangeError(self.id + 'to parameter specified is too large')
        else:
            # default to if none is specified
            params['to'] = self.iso8601(self.sum(maxTimePeriod, since))
        request = {
            'instrument': market['id'],
            'period': granularity['period'],
            'unit': granularity['unit'],
            'from': self.iso8601(since),
            'to': params['to'],
        }
        response = await self.publicGetCandlesticksInstrument(self.extend(request, params))
        return self.parse_ohlcvs(response, market, timeframe, since, limit)

    async def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        return await self.fetch_orders(symbol, since, limit, params)

    async def fetch_order(self, id, symbol=None, params={}):
        await self.load_markets()
        request = {
            'id': id,
        }
        response = await self.privateGetAccountOrdersId(self.extend(request, params))
        return self.parse_order(response)

    async def fetch_order_book(self, symbol, limit=None, params={}):
        await self.load_markets()
        request = {
            'instrument': self.market_id(symbol),
        }
        return await self.parse_book(request, params)

    async def fetch_orders(self, symbol=None, since=None, limit=None, params={}):
        await self.load_markets()
        request = {}
        market = None
        if symbol is not None:
            market = self.market(symbol)
            request['instrument_code'] = market['id']
        # from and to parameters are mutually inclusive
        if since is not None:
            # we define now as default to parameter
            to = self.iso8601(self.milliseconds())
            if 'to' in params:
                to = self.safe_string(params, 'to')
            request['to'] = to
            request['from'] = self.iso8601(since)
        if limit is not None:
            request['max_page_size'] = limit
        if 'with_cancelled_and_rejected' in params:
            request['with_cancelled_and_rejected'] = self.safe_string(params, 'with_cancelled_and_rejected')
        if 'with_just_filled_inactive' in params:
            request['with_just_filled_inactive'] = self.safe_string(params, 'with_just_filled_inactive')
        response = await self.privateGetAccountOrders(self.extend(request, params))
        orders = self.safe_value(response, 'order_history')
        if 'cursor' in response:
            cursor = self.safe_value(response, 'cursor')
            return self.add_paginator_cursor(self.parse_orders(orders, market, since, limit, params), cursor)
        return self.parse_orders(orders, market, since, limit, params)

    async def fetch_ticker(self, symbol, params={}):
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'instrument': market['id'],
        }
        ticker = await self.publicGetMarketTickerInstrument(self.extend(request, params))
        return self.parse_ticker(ticker)

    async def fetch_tickers(self, symbols=None, params={}):
        await self.load_markets()
        response = await self.publicGetMarketTicker(params)
        result = {}
        responseNum = len(response)
        for i in range(0, responseNum):
            symbol = self.translate_symbol(self.safe_string(response[i], 'instrument_code'))
            result[symbol] = self.parse_ticker(response[i])
        return result

    async def fetch_time(self, params={}):
        response = await self.publicGetTime(params)
        return self.safe_integer(response, 'epoch_millis')

    async def fetch_trading_fees(self, params={}):
        await self.load_markets()
        volumeResponse = await self.privateGetAccountTradingVolume(params)
        volume = self.safe_float(volumeResponse, 'volume')
        feeResponse = await self.privateGetAccountFees(params)
        tiers = self.safe_value(feeResponse, 'fee_tiers')
        for i in range(0, len(tiers) - 1):
            firstTier = tiers[i]
            secondTier = tiers[i + 1]
            firstTierVolume = self.safe_float(firstTier, 'volume')
            secondTierVolume = self.safe_float(secondTier, 'volume')
            if volume >= firstTierVolume and volume < secondTierVolume:
                return {
                    'info': feeResponse,
                    'maker': self.safe_float(firstTier, 'maker_fee') / 100,
                    'taker': self.safe_float(firstTier, 'taker_fee') / 100,
                }
        return {
            'info': feeResponse,
            'maker': self.fees.trading.maker,
            'taker': self.fees.trading.taker,
        }

    async def parse_book(self, request, params):
        response = await self.publicGetOrderBookInstrument(self.extend(request, params))
        time = self.safe_string(response, 'time')
        return self.parse_order_book(response, self.parse8601(time), 'bids', 'asks', 'price', 'amount')

    async def withdraw(self, code, amount, address, tag=None, params={}):
        await self.load_markets()
        self.check_address(address)
        currency = self.currency(code)
        request = {
            'currency': currency['id'],
            'amount': amount,
            'recipient': {
                'address': address,
            },
        }
        if tag is not None:
            request['recipient']['tag'] = tag
        response = self.privatePostAccountWithdrawCrypto(self.extend(request, params))
        return {
            'info': response,
            'id': None,
        }

    def parse_ohlcv(self, ohlcv, market=None, timeframe='1m', since=None, limit=None):
        return [
            self.parse8601(self.safe_string(ohlcv, 'time')),
            self.safe_float(ohlcv, 'open'),
            self.safe_float(ohlcv, 'high'),
            self.safe_float(ohlcv, 'low'),
            self.safe_float(ohlcv, 'close'),
            # Bitpanda's volume is in quote currency we are using total_amount which is in base currency instead
            self.safe_float(ohlcv, 'total_amount'),
        ]

    def parse_order(self, order, market=None):
        # example order response
        # {
        #   "order": {
        #     "order_id": "66756a10-3e86-48f4-9678-b634c4b135b2",
        #     "account_id": "1eb2ad5d-55f1-40b5-bc92-7dc05869e905",
        #     "instrument_code": "BTC_EUR",
        #     "amount": "1234.5678",
        #     "filled_amount": "1234.5678",
        #     "side": "BUY",
        #     "type": "LIMIT",
        #     "status": "OPEN",
        #     "sequence": 123456789,
        #     "price": "1234.5678",
        #     "average_price": "1234.5678",
        #     "reason": "INSUFFICIENT_FUNDS",
        #     "time": "2020-05-06T06:53:31Z",
        #     "time_in_force": "GOOD_TILL_CANCELLED",
        #     "time_last_updated": "2020-05-06T06:53:31Z",
        #     "expire_after": "2020-05-06T06:53:31Z",
        #     "is_post_only": False,
        #     "time_triggered": "2020-05-06T06:53:31Z",
        #     "trigger_price": "1234.5678"
        #   },
        #   "trades": [
        #     {
        #       "trade": {
        #         "trade_id": "2b42efcd-d5b7-4a56-8e12-b69ffd68c5ef",
        #         "order_id": "66756a10-3e86-48f4-9678-b634c4b135b2",
        #         "account_id": "c2d0076a-c20d-41f8-9e9a-1a1d028b2b58",
        #         "amount": "1234.5678",
        #         "side": "BUY",
        #         "instrument_code": "BTC_EUR",
        #         "price": "1234.5678",
        #         "time": "2020-05-06T06:53:31Z",
        #         "sequence": 123456789
        #       },
        #       "fee": {
        #         "fee_amount": "1234.5678",
        #         "fee_percentage": "1234.5678",
        #         "fee_group_id": "default",
        #         "running_trading_volume": "1234.5678",
        #         "fee_currency": "BTC",
        #         "fee_type": "TAKER"
        #       }
        #     }
        #   ]
        # }
        orderObject = self.safe_value(order, 'order', order)
        symbol = self.translate_symbol(self.safe_string(orderObject, 'instrument_code'))
        id = self.safe_string(orderObject, 'order_id')
        time = self.safe_string(orderObject, 'time')
        timestamp = self.parse8601(time)
        type = self.safe_string_lower(orderObject, 'type')
        side = self.safe_string_lower(orderObject, 'side')
        status = self.parse_order_status(self.safe_string(orderObject, 'status'))
        price = self.safe_float(orderObject, 'price')
        average = self.safe_float(orderObject, 'average_price', 0)
        amount = self.safe_float(orderObject, 'amount')
        filled = self.safe_float(orderObject, 'filled_amount', 0)
        # using average price which is actual filled price of the trades
        cost = average * amount
        remaining = amount - filled
        clientId = self.safe_string(orderObject, 'client_id')
        trades = None
        # may not contain any trades if not filled
        fills = self.safe_value(order, 'trades')
        if fills is not None:
            trades = self.parse_trades(fills, market)
        return {
            'id': id,
            'datetime': time,
            'timestamp': timestamp,
            'status': status,
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'average': average,
            'cost': cost,
            'clientOrderId': clientId,
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'trades': trades,
            # trades for one order can have multiple fee currencies, each trade contains self information of itself.
            'fee': None,
            'info': order,
        }

    def parse_ticker(self, ticker):
        timestamp = self.milliseconds()
        symbol = self.translate_symbol(self.safe_string(ticker, 'instrument_code'))
        last = self.safe_float(ticker, 'last_price')
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': self.safe_float(ticker, 'high'),
            'low': self.safe_float(ticker, 'low'),
            'bid': self.safe_float(ticker, 'best_bid'),
            'bidVolume': None,
            'ask': self.safe_float(ticker, 'best_ask'),
            'askVolume': None,
            'vwap': None,
            'open': None,
            'close': last,
            'last': last,
            'previousClose': None,
            'change': self.safe_float(ticker, 'price_change'),
            'percentage': self.safe_float(ticker, 'price_change_percentage'),
            'average': None,
            'baseVolume': self.safe_float(ticker, 'base_volume'),
            'quoteVolume': self.safe_float(ticker, 'quote_volume'),
            'info': ticker,
        }

    def parse_trade(self, trade, market=None):
        # Example Trade response
        # {
        #   "trade": {
        #     "trade_id": "2b42efcd-d5b7-4a56-8e12-b69ffd68c5ef",
        #     "order_id": "66756a10-3e86-48f4-9678-b634c4b135b2",
        #     "account_id": "c2d0076a-c20d-41f8-9e9a-1a1d028b2b58",
        #     "amount": "1234.5678",
        #     "side": "BUY",
        #     "instrument_code": "BTC_EUR",
        #     "price": "1234.5678",
        #     "time": "2020-05-06T06:53:31Z",
        #     "sequence": 123456789
        #   },
        #   "fee": {
        #     "fee_amount": "1234.5678",
        #     "fee_percentage": "0.10",
        #     "fee_group_id": "default",
        #     "running_trading_volume": "1234.5678",
        #     "fee_currency": "BTC",
        #     "fee_type": "TAKER"
        #   }
        # }
        tradeObject = self.safe_value(trade, 'trade')
        feeObject = self.safe_value(trade, 'fee')
        id = self.safe_string(tradeObject, 'trade_id')
        orderId = self.safe_string(tradeObject, 'order_id')
        time = self.safe_string(tradeObject, 'time')
        side = self.safe_string_lower(tradeObject, 'side')
        takerOrMaker = self.safe_string_lower(feeObject, 'fee_type')
        price = self.safe_float(tradeObject, 'price')
        amount = self.safe_float(tradeObject, 'amount')
        cost = price * amount
        symbol = self.translate_symbol(self.safe_string(tradeObject, 'instrument_code'))
        fee = {
            'cost': self.safe_float(feeObject, 'fee_amount'),
            'currency': self.safe_currency_code(self.safe_string(feeObject, 'fee_currency')),
            'rate': self.safe_float(feeObject, 'fee_percentage'),
        }
        return {
            'id': id,
            'info': trade,
            'datetime': time,
            'timestamp': self.parse8601(time),
            'symbol': symbol,
            'type': None,
            'order': orderId,
            'side': side,
            'takerOrMaker': takerOrMaker,
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': fee,
        }

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        request = '/' + self.implode_params(path, params)
        url = self.urls['api'][api] + self.version + request
        query = self.omit(params, self.extract_params(path))
        if headers is None:
            headers = {}
        if method == 'GET' or method == 'DELETE':
            if query:
                url += '?' + self.urlencode(query)
        elif method == 'POST':
            headers['Content-Type'] = 'application/json'
            body = self.json(query)
        if api == 'private':
            self.check_required_credentials()
            headers['Authorization'] = 'Bearer ' + self.apiKey
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, code, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if response is None:
            return
        if code < 400:
            return
        error = self.safe_value(response, 'error')
        if error is None:
            return
        exception = self.exceptions[error]
        if exception is not None:
            raise self.exceptions[error](error)
        raise ExchangeError(self.id + ' ' + self.json(response))

    def add_paginator_cursor(self, elements, cursor):
        if cursor and elements:
            # php transpiler making problems here with array length, thus self specific hint.
            lastElement = len(elements)
            elements[lastElement - 1]['info']['cursor'] = cursor
        return elements

    def parse_order_status(self, status):
        statuses = {
            'OPEN': 'open',
            'STOP_TRIGGERED': 'open',
            'FILLED': 'open',
            'FILLED_FULLY': 'closed',
            'FILLED_CLOSED': 'canceled',
            'FILLED_REJECTED': 'rejected',
            'REJECTED': 'rejected',
            'CLOSED': 'canceled',
            'FAILED': 'failed',
        }
        return self.safe_string(statuses, status, status)

    def translate_symbol(self, marketId):
        symbol = None
        if marketId is not None:
            if marketId in self.markets_by_id:
                market = self.markets_by_id[marketId]
                symbol = market['symbol']
            else:
                # if not found we just parse it as the format is known
                [baseId, quoteId] = marketId.split('_')
                base = self.safe_currency_code(baseId)  # unified
                quote = self.safe_currency_code(quoteId)
                symbol = base + '/' + quote
        return symbol
