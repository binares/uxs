# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.async_support.base.exchange import Exchange
import hashlib
from ccxt.base.errors import ExchangeError


class coinbene(Exchange):

    def describe(self):
        return self.deep_extend(super(coinbene, self).describe(), {
            'id': 'coinbene',
            'name': 'CoinBene',
            'countries': ['CN', 'US'],
            'version': 'v2',
            'rateLimit': 1500,
            'certified': True,
            # new metainfo interface
            'has': {
                'cancelOrder': False,
                'createLimitOrder': False,
                'createMarketOrder': False,
                'createOrder': False,
                'editOrder': False,
                'fetchBalance': False,
                'fetchOHLCV': False,
                'fetchTicker': False,
                'fetchTickers': True,
                'fetchTrades': False,
                'privateAPI': False,
            },
            'timeframes': {
                '1m': '1m',
                '5m': '5m',
                '15m': '15m',
                '30m': '30m',
                '1h': '1h',
                '3h': '3h',
                '6h': '6h',
                '12h': '12h',
                '1d': '1D',
                '1w': '7D',
                '2w': '14D',
                '1M': '1M',
            },
            'urls': {
                'logo': 'https://res.coinbene.mobi/coinbene-article/9f524eb71731f51e.png',
                'api': 'https://openapi-exchange.coinbene.com',
                'www': 'http://www.coinbene.com',
                'prefixPath': '/api/exchange/v2/',
                'referral': 'http://www.coinbene.com',
                'doc': [
                    'https://github.com/Coinbene/API-SPOT-v2-Documents',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        'market/tradePair/list',
                        'market/tradePair/one',
                        'market/ticker/list',
                        'market/ticker/one',
                        'market/orderBook',
                        'market/trades',
                        'market/instruments/candles',
                        'market/rate/list',
                    ],
                },
                'private': {
                    'get': [
                        'account/list',
                        'account/one',
                        'order/info',
                        'order/openOrders',
                        'order/closedOrders',
                        'order/trade/fills',
                    ],
                    'post': [
                        'order/place',
                        'order/cancel',
                        'order/batchCancel',
                        'order/batchPlaceOrder',
                    ],
                },
            },
            'options': {
                'currencyNames': None,
                'orderTypes': {
                    'limit': '1',
                    'market': '2',
                },
                'direction': {
                    'buy': '1',
                    'sell': '2',
                },
            },
        })

    async def fetch_markets(self, params={}):
        response = await self.publicGetMarketTradePairList(params)
        result = []
        for i in range(0, len(response['data'])):
            market = response['data'][i]
            id = self.safe_string(market, 'symbol').upper()
            base = None
            quote = None
            baseId = None
            quoteId = None
            if id.find('/') >= 0:
                parts = id.split('/')
                base = parts[0]
                baseId = base.lower()
                quote = parts[1]
                quoteId = quote.lower()
            symbol = base + '/' + quote
            id = baseId + quoteId
            precision = {
                'price': market['pricePrecision'],
                'amount': market['amountPrecision'],
            }
            priceFluctuation = self.safe_float(market, 'priceFluctuation')
            limits = {
                'amount': {
                    'min': self.safe_float(market, 'minAmount'),
                    'max': None,
                },
                'price': {
                    'min': 1 - priceFluctuation,
                    'max': 1 + priceFluctuation,
                },
            }
            limits['cost'] = {
                'min': limits['amount']['min'] * limits['price']['min'],
                'max': None,
            }
            result.append({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId,
                'quoteId': quoteId,
                'active': True,
                'precision': precision,
                'limits': limits,
                'info': market,
            })
        return result

    async def fetch_order_book(self, symbol, limit=None, params={}):
        await self.load_markets()
        if limit is None:
            limit = 10  # 5, 10, 50, 100. Default value 10
        request = {
            'symbol': symbol,
            'depth': limit,
        }
        response = await self.publicGetMarketOrderBook( self.extend(request, params))
        code = response['code']
        message = response['message']
        if code != 200:
            raise ExchangeError(self.id + ' message = ' + message)
        orderBook = response['data']
        timestamp = self.parse8601(self.safe_string(orderBook, 'timestamp'))
        return self.parse_order_book(orderBook, timestamp)
        return orderBook

    async def fetch_tickers(self, symbols=None, params={}):
        await self.load_markets()
        response = await self.publicGetMarketTickerList(params)
        return self.parse_tickers(response['data'], symbols)

    def parse_ticker(self, ticker, market=None):
        symbol = self.safe_string(ticker, 'symbol')
        last = self.safe_float(ticker, 'latestPrice')
        return {
            'symbol': symbol,
            'info': ticker,
            'timestamp': None,
            'datetime': None,
            'high': self.safe_float(ticker, 'high24h'),
            'low': self.safe_float(ticker, 'low24h'),
            'bid': self.safe_float(ticker, 'bestBid'),
            'bidVolume': None,
            'ask': self.safe_float(ticker, 'bestAsk'),
            'askVolume': None,
            'vwap': None,
            'open': None,
            'close': last,
            'last': last,
            'previousClose': None,
            'change': None,
            'percentage': None,
            'average': None,
            'baseVolume': self.safe_float(ticker, 'volume24h'),
            'quoteVolume': None,
        }

    def parse_tickers(self, rawTickers, symbols=None):
        tickers = []
        for i in range(0, len(rawTickers)):
            tickers.append(self.parse_ticker(rawTickers[i]))
        return self.filter_by_array(tickers, 'symbol', symbols)

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        path = self.urls['prefixPath'] + path
        isArray = isinstance(params, list)
        # request = '/api/' + api + '/' + self.version + '/'
        request = path if isArray else self.implode_params(path, params)
        query = params if isArray else self.omit(params, self.extract_params(path))
        url = self.urls['api'] + request
        if api == 'public':
            if query:
                url += '?' + self.urlencode(query)
        if api == 'private':
            self.check_required_credentials()
            timestamp = self.iso8601(self.milliseconds())
            headers = {
                'ACCESS-KEY': self.apiKey,
                'ACCESS-TIMESTAMP': timestamp,
            }
            auth = timestamp + method + request
            if method == 'GET':
                if query: 
                    urlencodedQuery = '?' + self.urlencode(query)
                    url += urlencodedQuery
                    auth += urlencodedQuery
            else:
                if isArray or query:
                    body = self.json(query)
                    auth += body
                headers['Content-Type'] = 'application/json'
            signature = self.hmac(self.encode(auth), self.encode(self.secret))  # , hashlib.sha256, 'hex')
            headers['ACCESS-SIGN'] = signature
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, code, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if response is None:
            return
        if code >= 400:
            if body[0] == '{':
                feedback = self.id + ' ' + body
                message = self.safe_string_2(response, 'message', 'error')
                self.throw_exactly_matched_exception(self.exceptions['exact'], message, feedback)
                self.throw_broadly_matched_exception(self.exceptions['broad'], message, feedback)
                raise ExchangeError(feedback)  # unknown message
